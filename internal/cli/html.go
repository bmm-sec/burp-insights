package cli

import (
	"fmt"
	"html/template"
	"io"
	"os"
	"sort"
	"strings"
	"time"

	"github.com/bmm-sec/burp-insights/pkg/burp"
)

type reportView struct {
	Title        string
	GeneratedAt  string
	FooterNote   string
	FooterDate   string
	SummaryCards []reportCardView
	Issues       *issuesSectionView
	Tasks        *tasksSectionView
	Repeater     *repeaterSectionView
	History      *historySectionView
	SiteMap      *siteMapSectionView
}

type reportCardView struct {
	Title string
	Value string
}

type issuesSectionView struct {
	Total       int
	TypeOptions []issueTypeOptionView
	Groups      []issueGroupView
	MaxNotice   string
}

type issueTypeOptionView struct {
	ID    string
	Label string
}

type issueGroupView struct {
	TypeID           string
	Name             string
	MaxSeverity      string
	MaxSeverityClass string
	Count            int
	Issues           []issueRowView
}

type issueRowView struct {
	Index           int
	Serial          uint64
	Severity        string
	SeverityClass   string
	Confidence      string
	ConfidenceClass string
	Host            string
	Path            string
	TypeID          string
	Search          string
	Details         issueDetailView
}

type issueDetailView struct {
	ID              string
	Name            string
	TypeID          string
	TaskID          uint64
	Host            string
	Path            string
	Location        string
	Severity        string
	Confidence      string
	Description     template.HTML
	Remediation     template.HTML
	Overview        template.HTML
	References      []issueReferenceView
	Classifications []issueReferenceView
	Evidence        []issueEvidenceView
	EvidenceNotice  string
}

type issueReferenceView struct {
	Title string
	URL   string
}

type issueEvidenceView struct {
	Index       int
	Request     string
	Response    string
	HasRequest  bool
	HasResponse bool
}

type tasksSectionView struct {
	Total     int
	Tasks     []taskView
	MaxNotice string
}

type taskView struct {
	Index int
	Name  string
	Type  uint16
	Scope string
	ID    int64
}

type repeaterSectionView struct {
	Total     int
	Tabs      []string
	MaxNotice string
}

type historySectionView struct {
	Total         int
	Entries       []historyEntryView
	MaxNotice     string
	IncludeBodies bool
}

type historyEntryView struct {
	ID              uint64
	Method          string
	MethodClass     string
	Host            string
	Path            string
	Status          int
	StatusClass     string
	Size            string
	Expandable      bool
	RequestPreview  string
	ResponsePreview string
	HasResponse     bool
}

type siteMapSectionView struct {
	HasData bool
	Hosts   []siteMapNodeView
}

type siteMapNodeView struct {
	Label    string
	Count    int
	CopyValue string
	Children []siteMapNodeView
}

func generateHTMLReport(w io.Writer, report *ReportData, opts ReportOptions) error {
	view := buildReportView(report, opts)

	tmpl, err := loadReportTemplate()
	if err != nil {
		return err
	}

	if tmpl.Lookup("report") != nil {
		return tmpl.ExecuteTemplate(w, "report", view)
	}
	return tmpl.Execute(w, view)
}

func loadReportTemplate() (*template.Template, error) {
	if strings.TrimSpace(reportTemplate) != "" {
		data, err := os.ReadFile(reportTemplate)
		if err != nil {
			return nil, fmt.Errorf("read report template: %w", err)
		}
		return template.New("report").Parse(string(data))
	}

	return template.New("report").ParseFS(reportTemplateFS, "templates/report.html")
}

func buildReportView(report *ReportData, opts ReportOptions) reportView {
	now := time.Now()

	stats := Stats{}
	if opts.Sections.History && len(report.History) > 0 {
		stats = calculateStats(report.History)
	}

	view := reportView{
		Title:        opts.Title,
		GeneratedAt:  now.Format("January 2, 2006 at 3:04 PM"),
		FooterNote:   "Generated by burp-insights",
		FooterDate:   now.Format("2006-01-02"),
		SummaryCards: buildSummaryCards(report, opts, stats),
	}

	if opts.Sections.Issues {
		view.Issues = buildIssuesSection(report.Issues, opts)
	}
	if opts.Sections.Tasks {
		view.Tasks = buildTasksSection(report.Tasks, opts)
	}
	if opts.Sections.Repeater {
		view.Repeater = buildRepeaterSection(report.RepeaterTabs, opts)
	}
	if opts.Sections.History {
		view.History = buildHistorySection(report.History, opts)
	}
	if opts.Sections.Sitemap {
		view.SiteMap = buildSiteMapSection(report.SiteMap)
	}

	if opts.Sections.History {
		view.FooterNote = fmt.Sprintf("%s | %d requests analyzed", view.FooterNote, len(report.History))
	} else if opts.Sections.Issues {
		view.FooterNote = fmt.Sprintf("%s | %d issues analyzed", view.FooterNote, len(report.Issues))
	}

	return view
}

func buildSummaryCards(report *ReportData, opts ReportOptions, stats Stats) []reportCardView {
	var cards []reportCardView
	if opts.Sections.History {
		cards = append(cards, reportCardView{Title: "Total Requests", Value: fmt.Sprintf("%d", stats.TotalRequests)})
		cards = append(cards, reportCardView{Title: "Unique Hosts", Value: fmt.Sprintf("%d", stats.UniqueHosts)})
		cards = append(cards, reportCardView{Title: "Success Rate", Value: fmt.Sprintf("%.1f%%", stats.SuccessRate)})
		cards = append(cards, reportCardView{Title: "Error Rate", Value: fmt.Sprintf("%.1f%%", stats.ErrorRate)})
	}
	if opts.Sections.Issues {
		cards = append(cards, reportCardView{Title: "Issues", Value: fmt.Sprintf("%d", len(report.Issues))})
	}
	if opts.Sections.Tasks {
		cards = append(cards, reportCardView{Title: "Tasks", Value: fmt.Sprintf("%d", len(report.Tasks))})
	}
	if opts.Sections.Repeater {
		cards = append(cards, reportCardView{Title: "Repeater Tabs", Value: fmt.Sprintf("%d", len(report.RepeaterTabs))})
	}
	if opts.Sections.Sitemap && report.SiteMap != nil {
		cards = append(cards, reportCardView{Title: "Site Map Hosts", Value: fmt.Sprintf("%d", len(report.SiteMap.Root))})
	}
	return cards
}

func buildIssuesSection(issues []burp.ScannerIssueMeta, opts ReportOptions) *issuesSectionView {
	total := len(issues)
	section := &issuesSectionView{Total: total}
	if total == 0 {
		return section
	}

	sorted := sortIssuesForReport(issues)
	display := sorted
	if opts.MaxIssues > 0 && total > opts.MaxIssues {
		display = sorted[:opts.MaxIssues]
		section.MaxNotice = fmt.Sprintf("Showing %d of %d issues. Increase --max-issues to include more.", len(display), total)
	}

	groups := groupIssuesByType(display)
	for _, group := range groups {
		typeID := fmt.Sprintf("0x%08x", group.TypeID)
		groupView := issueGroupView{
			TypeID:           typeID,
			Name:             group.Name,
			MaxSeverity:      group.MaxSeverity.String(),
			MaxSeverityClass: severityBadgeClass(group.MaxSeverity),
			Count:            len(group.Issues),
		}

		for idx, issue := range group.Issues {
			row := buildIssueRowView(idx+1, issue, opts, typeID)
			groupView.Issues = append(groupView.Issues, row)
		}

		section.Groups = append(section.Groups, groupView)
	}

	for _, group := range section.Groups {
		section.TypeOptions = append(section.TypeOptions, issueTypeOptionView{
			ID:    group.TypeID,
			Label: fmt.Sprintf("%s (%s)", group.Name, group.TypeID),
		})
	}
	if len(section.TypeOptions) > 0 {
		sort.Slice(section.TypeOptions, func(i, j int) bool {
			return section.TypeOptions[i].Label < section.TypeOptions[j].Label
		})
	}

	return section
}

func buildIssueRowView(index int, issue burp.ScannerIssueMeta, opts ReportOptions, typeID string) issueRowView {
	name := issueDisplayName(issue)

	host := issue.Host
	path := issue.Path
	if host == "" && path == "" && issue.Location != "" {
		path = issue.Location
	}

	hostLabel := host
	if hostLabel == "" {
		hostLabel = "-"
	}
	pathLabel := path
	if pathLabel == "" {
		pathLabel = "-"
	}

	location := issue.Location
	if location == "" {
		location = "-"
	}

	detailsID := fmt.Sprintf("issue-%d", issue.SerialNumber)
	search := strings.ToLower(fmt.Sprintf("%s %s %s %s %s %d %d", name, typeID, host, path, issue.Location, issue.SerialNumber, issue.TaskID))

	details := issueDetailView{
		ID:         detailsID,
		Name:       name,
		TypeID:     typeID,
		TaskID:     issue.TaskID,
		Host:       hostLabel,
		Path:       pathLabel,
		Location:   location,
		Severity:   issue.Severity.String(),
		Confidence: issue.Confidence.String(),
	}

	if issue.Definition != nil {
		if issue.Definition.Description != "" {
			details.Description = template.HTML(issue.Definition.Description)
		}
		if issue.Definition.Remediation != "" {
			details.Remediation = template.HTML(issue.Definition.Remediation)
		}
		if issue.Definition.WebIntro != "" {
			details.Overview = template.HTML(issue.Definition.WebIntro)
		}
		if len(issue.Definition.References) > 0 {
			for _, ref := range issue.Definition.References {
				details.References = append(details.References, issueReferenceView{Title: ref.Title, URL: ref.URL})
			}
		}
		if len(issue.Definition.VulnerabilityClassifications) > 0 {
			for _, ref := range issue.Definition.VulnerabilityClassifications {
				details.Classifications = append(details.Classifications, issueReferenceView{Title: ref.Title, URL: ref.URL})
			}
		}
	}

	if opts.IncludeEvidence && len(issue.Evidence) > 0 {
		evidence := issue.Evidence
		if opts.MaxEvidenceItems > 0 && len(evidence) > opts.MaxEvidenceItems {
			evidence = evidence[:opts.MaxEvidenceItems]
			details.EvidenceNotice = fmt.Sprintf("Showing %d of %d evidence item(s).", len(evidence), len(issue.Evidence))
		}

		for idx, ev := range evidence {
			view := issueEvidenceView{Index: idx + 1}
			if ev.Request != nil {
				view.Request = formatExportedMessagePreview(ev.Request, opts.IncludeBodies, opts.MaxBodySize)
				view.HasRequest = true
			}
			if ev.Response != nil {
				view.Response = formatExportedMessagePreview(ev.Response, opts.IncludeBodies, opts.MaxBodySize)
				view.HasResponse = true
			}
			details.Evidence = append(details.Evidence, view)
		}
	}

	return issueRowView{
		Index:           index,
		Serial:          issue.SerialNumber,
		Severity:        issue.Severity.String(),
		SeverityClass:   severityBadgeClass(issue.Severity),
		Confidence:      issue.Confidence.String(),
		ConfidenceClass: confidenceBadgeClass(issue.Confidence),
		Host:            hostLabel,
		Path:            pathLabel,
		TypeID:          typeID,
		Search:          search,
		Details:         details,
	}
}

func buildTasksSection(tasks []burp.UITask, opts ReportOptions) *tasksSectionView {
	total := len(tasks)
	section := &tasksSectionView{Total: total}
	if total == 0 {
		return section
	}

	display := tasks
	if opts.MaxTasks > 0 && total > opts.MaxTasks {
		display = tasks[:opts.MaxTasks]
		section.MaxNotice = fmt.Sprintf("Showing %d of %d tasks. Increase --max-tasks to include more.", len(display), total)
	}

	for idx, task := range display {
		section.Tasks = append(section.Tasks, taskView{
			Index: idx + 1,
			Name:  task.Name,
			Type:  task.Type,
			Scope: task.Scope,
			ID:    task.ID,
		})
	}

	return section
}

func buildRepeaterSection(tabs []string, opts ReportOptions) *repeaterSectionView {
	total := len(tabs)
	section := &repeaterSectionView{Total: total}
	if total == 0 {
		return section
	}

	display := tabs
	if opts.MaxRepeater > 0 && total > opts.MaxRepeater {
		display = tabs[:opts.MaxRepeater]
		section.MaxNotice = fmt.Sprintf("Showing %d of %d tabs. Increase --max-repeater to include more.", len(display), total)
	}

	section.Tabs = append(section.Tabs, display...)
	return section
}

func buildHistorySection(entries []burp.HTTPEntry, opts ReportOptions) *historySectionView {
	total := len(entries)
	section := &historySectionView{Total: total, IncludeBodies: opts.IncludeBodies}
	if total == 0 {
		return section
	}

	display := entries
	if opts.MaxHistory > 0 && total > opts.MaxHistory {
		display = entries[:opts.MaxHistory]
		section.MaxNotice = fmt.Sprintf("Showing %d of %d entries. Increase --max-history to include more.", len(display), total)
	}

	for _, entry := range display {
		row := historyEntryView{
			ID:          entry.ID,
			Method:      entry.Method,
			MethodClass: "method-" + entry.Method,
			Host:        entry.Host,
			Path:        entry.Path,
			Status:      entry.StatusCode,
			StatusClass: getStatusClass(entry.StatusCode),
			Size:        formatSizeShort(entry.ContentLength),
			Expandable:  opts.IncludeBodies,
		}

		if opts.IncludeBodies {
			row.RequestPreview = formatRequestPreview(entry, opts.MaxBodySize)
			if entry.Response != nil {
				row.ResponsePreview = formatResponsePreview(entry, opts.MaxBodySize)
				row.HasResponse = true
			}
		}

		section.Entries = append(section.Entries, row)
	}

	return section
}

func buildSiteMapSection(siteMap *burp.SiteMap) *siteMapSectionView {
	section := &siteMapSectionView{}
	if siteMap == nil || len(siteMap.Root) == 0 {
		return section
	}

	hosts := make([]string, 0, len(siteMap.Root))
	for host := range siteMap.Root {
		hosts = append(hosts, host)
	}
	sort.Strings(hosts)

		for _, host := range hosts {
			node := siteMap.Root[host]
			section.Hosts = append(section.Hosts, buildSiteMapNode(host, host, node))
		}

		section.HasData = len(section.Hosts) > 0
		return section
	}

func buildSiteMapNode(host string, label string, node *burp.SiteMapNode) siteMapNodeView {
	protocol := selectSiteMapProtocol(node)
	path := "/"
	if node != nil && node.Path != "" {
		path = node.Path
	}

	copyValue := host + path
	if protocol != "" {
		copyValue = protocol + "://" + copyValue
	}

	view := siteMapNodeView{
		Label:    label,
		Count:    countSiteMapEntries(node),
		CopyValue: copyValue,
	}

	if node == nil || len(node.Children) == 0 {
		return view
	}

	keys := make([]string, 0, len(node.Children))
	for key := range node.Children {
		keys = append(keys, key)
	}
	sort.Strings(keys)
	for _, key := range keys {
		view.Children = append(view.Children, buildSiteMapNode(host, key, node.Children[key]))
	}

	return view
}

func selectSiteMapProtocol(node *burp.SiteMapNode) string {
	if node == nil {
		return ""
	}

	hasHTTP := false
	for _, entry := range node.Entries {
		switch strings.ToLower(entry.Protocol) {
		case "https", "wss":
			return "https"
		case "http", "ws":
			hasHTTP = true
		}
	}

	for _, child := range node.Children {
		proto := selectSiteMapProtocol(child)
		if proto == "https" {
			return "https"
		}
		if proto == "http" {
			hasHTTP = true
		}
	}

	if hasHTTP {
		return "http"
	}
	return ""
}

func countSiteMapEntries(node *burp.SiteMapNode) int {
	if node == nil {
		return 0
	}

	total := len(node.Entries)
	for _, child := range node.Children {
		total += countSiteMapEntries(child)
	}
	return total
}

func severityBadgeClass(sev burp.Severity) string {
	switch sev {
	case burp.SeverityInfo:
		return "badge-info"
	case burp.SeverityLow:
		return "badge-warning"
	case burp.SeverityMedium:
		return "badge-warning"
	case burp.SeverityHigh:
		return "badge-error"
	default:
		return "badge-info"
	}
}

func confidenceBadgeClass(conf burp.Confidence) string {
	switch conf {
	case burp.ConfidenceTentative:
		return "badge-tentative"
	case burp.ConfidenceFirm:
		return "badge-firm"
	case burp.ConfidenceCertain:
		return "badge-certain"
	default:
		return "badge-neutral"
	}
}

const unknownIssueName = "Unknown"

type issueGroup struct {
	TypeID      uint32
	Name        string
	Issues      []burp.ScannerIssueMeta
	MaxSeverity burp.Severity
}

func issueDisplayName(issue burp.ScannerIssueMeta) string {
	if issue.Definition != nil && issue.Definition.Name != "" {
		return issue.Definition.Name
	}
	return unknownIssueName
}

func severitySortValue(sev burp.Severity) int {
	switch sev {
	case burp.SeverityHigh:
		return 3
	case burp.SeverityMedium:
		return 2
	case burp.SeverityLow:
		return 1
	case burp.SeverityInfo:
		return 0
	default:
		return -1
	}
}

func confidenceSortValue(conf burp.Confidence) int {
	switch conf {
	case burp.ConfidenceCertain:
		return 2
	case burp.ConfidenceFirm:
		return 1
	case burp.ConfidenceTentative:
		return 0
	default:
		return -1
	}
}

func sortIssuesForReport(issues []burp.ScannerIssueMeta) []burp.ScannerIssueMeta {
	sorted := append([]burp.ScannerIssueMeta(nil), issues...)
	sort.SliceStable(sorted, func(i, j int) bool {
		severityI := severitySortValue(sorted[i].Severity)
		severityJ := severitySortValue(sorted[j].Severity)
		if severityI != severityJ {
			return severityI > severityJ
		}
		confidenceI := confidenceSortValue(sorted[i].Confidence)
		confidenceJ := confidenceSortValue(sorted[j].Confidence)
		if confidenceI != confidenceJ {
			return confidenceI > confidenceJ
		}
		nameI := issueDisplayName(sorted[i])
		nameJ := issueDisplayName(sorted[j])
		if nameI != nameJ {
			return nameI < nameJ
		}
		return sorted[i].SerialNumber < sorted[j].SerialNumber
	})
	return sorted
}

func groupIssuesByType(issues []burp.ScannerIssueMeta) []issueGroup {
	groups := make(map[uint32]*issueGroup)
	for _, issue := range issues {
		group, ok := groups[issue.Type]
		if !ok {
			group = &issueGroup{
				TypeID:      issue.Type,
				MaxSeverity: issue.Severity,
			}
			groups[issue.Type] = group
		}

		name := issueDisplayName(issue)
		if name != unknownIssueName {
			group.Name = name
		} else if group.Name == "" {
			group.Name = name
		}

		if severitySortValue(issue.Severity) > severitySortValue(group.MaxSeverity) {
			group.MaxSeverity = issue.Severity
		}
		group.Issues = append(group.Issues, issue)
	}

	var grouped []issueGroup
	for _, group := range groups {
		if group.Name == "" {
			group.Name = unknownIssueName
		}

		sort.SliceStable(group.Issues, func(i, j int) bool {
			severityI := severitySortValue(group.Issues[i].Severity)
			severityJ := severitySortValue(group.Issues[j].Severity)
			if severityI != severityJ {
				return severityI > severityJ
			}
			confidenceI := confidenceSortValue(group.Issues[i].Confidence)
			confidenceJ := confidenceSortValue(group.Issues[j].Confidence)
			if confidenceI != confidenceJ {
				return confidenceI > confidenceJ
			}
			return group.Issues[i].SerialNumber < group.Issues[j].SerialNumber
		})

		grouped = append(grouped, *group)
	}

	sort.SliceStable(grouped, func(i, j int) bool {
		severityI := severitySortValue(grouped[i].MaxSeverity)
		severityJ := severitySortValue(grouped[j].MaxSeverity)
		if severityI != severityJ {
			return severityI > severityJ
		}
		if grouped[i].Name != grouped[j].Name {
			return grouped[i].Name < grouped[j].Name
		}
		return grouped[i].TypeID < grouped[j].TypeID
	})

	return grouped
}

type Stats struct {
	TotalRequests int
	UniqueHosts   int
	SuccessRate   float64
	ErrorRate     float64
	HostCounts    map[string]int
	MethodCounts  map[string]int
	StatusCounts  map[int]int
}

func calculateStats(entries []burp.HTTPEntry) Stats {
	stats := Stats{
		TotalRequests: len(entries),
		HostCounts:    make(map[string]int),
		MethodCounts:  make(map[string]int),
		StatusCounts:  make(map[int]int),
	}

	successCount := 0
	errorCount := 0

	for _, entry := range entries {
		stats.MethodCounts[entry.Method]++
		stats.HostCounts[entry.Host]++
		stats.StatusCounts[entry.StatusCode]++

		if entry.StatusCode >= 200 && entry.StatusCode < 400 {
			successCount++
		} else if entry.StatusCode >= 400 {
			errorCount++
		}
	}

	stats.UniqueHosts = len(stats.HostCounts)
	if stats.TotalRequests > 0 {
		stats.SuccessRate = float64(successCount) / float64(stats.TotalRequests) * 100
		stats.ErrorRate = float64(errorCount) / float64(stats.TotalRequests) * 100
	}

	return stats
}

func getStatusClass(code int) string {
	switch {
	case code >= 200 && code < 300:
		return "status-2xx"
	case code >= 300 && code < 400:
		return "status-3xx"
	case code >= 400 && code < 500:
		return "status-4xx"
	case code >= 500:
		return "status-5xx"
	default:
		return ""
	}
}

func formatRequestPreview(entry burp.HTTPEntry, maxBodySize int) string {
	if entry.Request == nil || entry.Request.Raw == nil {
		return entry.Method + " " + entry.Path + " " + entry.Protocol
	}

	raw := string(entry.Request.Raw)
	raw = truncateReportString(raw, maxBodySize)
	return raw
}

func formatResponsePreview(entry burp.HTTPEntry, maxBodySize int) string {
	if entry.Response == nil || entry.Response.Raw == nil {
		return "No response"
	}

	raw := string(entry.Response.Raw)
	raw = truncateReportString(raw, maxBodySize)
	return raw
}

func formatExportedMessagePreview(msg *burp.ExportedMessage, includeBodies bool, maxBodySize int) string {
	if msg == nil {
		return "No data"
	}

	raw := ""
	if includeBodies && msg.Raw != "" {
		raw = msg.Raw
	} else {
		var b strings.Builder
		if msg.StartLine != "" {
			b.WriteString(msg.StartLine)
			b.WriteString("\n")
		}
		for key, value := range msg.Headers {
			b.WriteString(key)
			b.WriteString(": ")
			b.WriteString(value)
			b.WriteString("\n")
		}
		if includeBodies && msg.Body != "" {
			b.WriteString("\n")
			b.WriteString(msg.Body)
		}
		raw = b.String()
	}

	raw = truncateReportString(raw, maxBodySize)
	return raw
}

func truncateReportString(s string, maxLen int) string {
	if maxLen <= 0 || len(s) <= maxLen {
		return s
	}
	return s[:maxLen] + "\n... (truncated)"
}
